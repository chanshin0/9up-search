# 2024 엘리스 커리어 부스트 위크 프론트엔드

# 프로젝트 개요

이 프로젝트는 사용자가 원하는 조건에 따라 코스 데이터를 필터링하고, 조건에 맞는 검색결과를 하단에 UI로 제공하는 과제입니다. 주요 기능은 검색, 필터링, 페이지네이션, API 연동 등을 포함하며, Next.js와 TypeScript를 사용하여 개발되었습니다.

## 주요 기능

### 1. 필터링 기능

사용자는 `유형`, `진행 방식`, `분야`, `난이도`, `언어`, `가격`과 같은 다양한 필터 조건을 선택할 수 있으며, 각 필터는 URL 쿼리 파라미터로 구현했습니다. 필터 선택 및 취소 시 URL의 쿼리 파라미터가 실시간으로 업데이트되며, 해당 조건에 맞는 코스들이 필터링됩니다.

- **필터링 로직**
  - `createFilterQuery` 함수는 선택된 필터 데이터를 기반으로 필터 조건을 생성하고, 이를 URL 쿼리로 변환해 API에 전달합니다.
  - 다중 필터 선택이 가능하며, 각 카테고리 내 필터는 OR 연산으로, 카테고리 간에는 AND 연산으로 처리됩니다.

### 2. 검색 기능

`SearchArea` 컴포넌트는 사용자가 검색어를 입력할 때 300ms 디바운스를 적용해 효율적인 검색이 가능합니다. 검색어는 URL 쿼리 파라미터에 저장되며, API 요청 시 필터 조건과 함께 전달됩니다.

### 3. 페이지네이션 기능

한 페이지당 최대 20개의 코스가 표시되며, `Pagination` 컴포넌트를 통해 사용자는 페이지를 이동할 수 있습니다. API 요청 시 `offset`과 `count` 값을 사용하여 데이터를 처리하며, Api Route 기능을 활용해 클라이언트에서 로직을 숨기고 백엔드에서 데이터를 받아옵니다.

### 4. API 통신

코스 데이터는 제공받은 엘리스의 API를 통해 가져옵니다. 사용자가 선택한 필터 및 검색어, 페이지 번호 등의 정보는 쿼리 파라미터로 전달되며, 서버로부터 데이터를 받아와 UI에 반영합니다.

### 5. 상태 관리 및 URL 동기화

`useSearchParams`와 `useRouter`를 사용해 URL 쿼리 파라미터와 상태를 동기화했습니다. 이를 통해 필터 선택, 검색어 입력, 페이지 이동 등의 동작이 모두 URL에 반영되며, 새로고침 후에도 상태가 유지됩니다.

## 타입스크립트 적용

- 각 컴포넌트와 함수에 TypeScript 타입을 적용하여 코드의 안정성과 가독성을 높였습니다.
- `Course`, `FilterConditions` 등의 인터페이스를 정의하여 데이터 모델을 명확하게 설정하였습니다. 이를 통해 API로부터 받은 데이터를 적절히 처리하고 각 기능에 맞게 사용할 수 있도록 구현했습니다.

## 기술 스택

- **Next.js**: 페이지 기반 라우팅 및 서버 사이드 렌더링을 지원하는 프레임워크로, 효율적인 URL 동기화 및 API 호출을 처리했습니다.
- **TypeScript**: 타입 안정성을 확보하여 오류를 최소화하고, 코드의 유지보수를 용이하게 했습니다.
- **Emotion**: 스타일링을 위한 CSS-in-JS 라이브러리로, 컴포넌트마다 독립적인 스타일을 적용했습니다.
- **Material UI (MUI)**: 필터 컴포넌트와 Chip컴포넌트에서 간편하게 스타일링을 적용하기 위해 MUI 컴포넌트를 사용했습니다.

## 구현 과정

### 필터링 로직

각 필터가 동작할 수 있도록 URL 쿼리 파라미터를 사용하였으며, 선택된 필터 조건을 `createFilterQuery` 함수로 변환해 API에 전달했습니다.

### 검색 디바운스

실시간 검색 시 불필요한 API 호출을 방지하기 위해 300ms의 디바운스 로직을 적용했으며, 입력된 검색어는 URL 쿼리에 반영되어 새로고침 시에도 검색 상태가 유지되도록 했습니다.

### URL 기반 상태 관리

필터, 검색, 페이지네이션 상태를 URL에 저장하고, `useSearchParams`와 `useRouter`를 통해 각 기능을 동기화하여 사용자의 편의를 높였습니다.

## 향후 개선 사항

1. **에러 처리**: API 호출 시 발생할 수 있는 다양한 에러 케이스에 대해 사용자에게 피드백을 제공하는 로직 추가.
2. **필터 최적화**: 캐싱을 활용해 다수의 필터를 선택한 경우 성능을 개선하기 위한 최적화 작업 필요.
3. **유저 인터랙션 개선**: 로딩 컴포넌트와 필터를 더욱 직관적으로 사용할 수 있도록 UI/UX 개선.
